---
heroImage: https://md.p1gd0g.cc/mmbiz_png/OQRlA7Uf7SX2pAVwW553vuDsyHibqr5hJTxF0T7zeS7GictWuiavbKWrSNgFq668aVNhxnVufFFiaPeaplgXR7ezQg/0?from=appmsg

title: handle nested scrolls but not only scroll in Flutter
tags: [编程, EN]
pubDate: 2025 年 08 月 25 日 17:38:19
---

Sometimes we should handle nested scrolls but not only scroll widget, such as zoomable widget, in such case we can not use [NestedScrollView](https://api.flutter.dev/flutter/widgets/NestedScrollView-class.html) or [NotificationListener](https://api.flutter.dev/flutter/widgets/NestedScrollView-class.html) because zoomable widget may not receive [ScrollNotification](https://api.flutter.dev/flutter/widgets/ScrollNotification-class.html).

For example, we have such a widget:

```dart
class ScrollableWidget extends StatelessWidget {
  const ScrollableWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final Controller controller = Get.put(Controller());
    return Listener(
      onPointerSignal: (e) {
        if (e is PointerScrollEvent) {
              x.value++;
          } else if (e.scrollDelta.dy < 0) {
              x.value--;
          }
        }
      },
      child: Obx(() => Text('on mouse wheel up/down ${x.value}')),
    );
  }
}
```

We build it inside a SingleChildScrollView:

![](https://md.p1gd0g.cc/mmbiz_gif/OQRlA7Uf7SX2pAVwW553vuDsyHibqr5hJ9VlYa4p9pHmCZ7ApQsFNYwBRZIMpJkq8ErxgibEEbib0wXPmwqlOjnaA/0?wx_fmt=gif)

Obviously, it is a bad experience. How could we handle this case? A quick way is to controll the [ScrollPhysics](https://api.flutter.dev/flutter/widgets/ScrollPhysics-class.html) of scrollable widget.

First we create a custom ScrollPhysics and override allowUserScrolling:

```dart
      home: SingleChildScrollView(
        physics: CustomScrollPhysics(Get.put(Controller())),
        child: Column(
          children: [
            ...List.generate(7, (index) => Text('Item $index')),
            ScrollableWidget(),
            ...List.generate(7, (index) => Text('Item $index')),
          ],
        ),
      ),

      class CustomScrollPhysics extends ScrollPhysics {
      const CustomScrollPhysics(this.controll, {super.parent});

      final Controller controll;

      @override
      ScrollPhysics applyTo(ScrollPhysics? ancestor) {
        return CustomScrollPhysics(controll, parent: buildParent(ancestor));
      }

      @override
      bool get allowUserScrolling => controll.enableScroll;
    }
```

Then we handle the `enableScroll` from our widget:

```dart
class ScrollableWidget extends StatelessWidget {
  const ScrollableWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final Controller controller = Get.put(Controller());
    return Listener(
      onPointerSignal: (e) {
        if (e is PointerScrollEvent) {
          if (e.scrollDelta.dy > 0) {
            if (x < 10) {
              controller.enableScroll = false;
              x.value++;
            } else {
              controller.enableScroll = true;
            }
          } else if (e.scrollDelta.dy < 0) {
            if (x > 0) {
              Get.put(Controller()).enableScroll = false;
              x.value--;
            } else {
              controller.enableScroll = true;
            }
          }
        }
      },
      child: Obx(() => Text('on mouse wheel up/down ${x.value}')),
    );
  }
}
```

That's it!

![](https://md.p1gd0g.cc/mmbiz_gif/OQRlA7Uf7SX2pAVwW553vuDsyHibqr5hJmFQoxR2WyL88MoZ51IePkM5jETUFicHvzXI9B1LuvjSnGq9ibliag0IaQ/0?wx_fmt=gif)

It is not the only way to handle the case, sometimes you need override the handleEvent method. For example, we extends [ZoomPanBehavior](https://pub.dev/documentation/syncfusion_flutter_charts/latest/charts/ZoomPanBehavior-class.html) when we use `syncfusion_flutter_charts` package:

```dart
class CustomZoomPanBehavior extends ZoomPanBehavior {
  CustomZoomPanBehavior(
  		// ...
  });

  @override
  void handleEvent(PointerEvent event, BoxHitTestEntry entry) {
    if (event is PointerScrollEvent) {
      if (event.scrollDelta.dy < 0) {
        enableScroll = axisController.zoomFactor <= 0.1;
      } else {
        enableScroll = axisController.zoomFactor >= 1.0;
      }
    } else {
      enableScroll = true;
    }
    super.handleEvent(event, entry);
  }
}
```
